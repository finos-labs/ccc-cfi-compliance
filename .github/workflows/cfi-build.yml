name: CFI Build

permissions:
  id-token: write
  contents: read

on:
  workflow_dispatch:
  push:
    branches: [main]

jobs:
  prepare-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Generate matrix from config files
        id: set-matrix
        run: |
          TARGETS_DIR=config
          matrix='{"target": []}'

          for target_file in $TARGETS_DIR/*.json; do
            if [[ "$target_file" == *".json" ]]; then
              id=$(jq -r '.id' "$target_file")
              name=$(jq -r '.name' "$target_file")
              path=$(jq -r '.path' "$target_file")
              provider=$(jq -r '.provider' "$target_file")
              service=$(jq -r '.service' "$target_file")
              
              target_json=$(jq -c '.' "$target_file")
              matrix=$(echo "$matrix" | jq --argjson target "$target_json" '.target += [$target]')
            fi
          done

          echo "matrix={\"target\": $(echo "$matrix" | jq -c '.target')}" >> $GITHUB_OUTPUT
          echo "Generated matrix with $(echo "$matrix" | jq '.target | length') targets"

  deploy-and-scan:
    needs: prepare-matrix
    runs-on: ubuntu-latest
    strategy:
      matrix:
        target: ${{ fromJson(needs.prepare-matrix.outputs.matrix).target }}
      fail-fast: false

    env:
      AWS_REGION: us-east-1
      OUTPUT_DIR: results
      TARGET_ID: ${{ matrix.target.id }}
      TARGET_NAME: ${{ matrix.target.name }}
      TARGET_PATH: ${{ matrix.target.path }}
      TARGET_PROVIDER: ${{ matrix.target.provider }}
      TARGET_SERVICE: ${{ matrix.target.service }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Configure AWS Credentials (OIDC)
        if: matrix.target.provider == 'aws'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/TerraformRole
          aws-region: ${{ env.AWS_REGION }}

      - name: Configure Azure Credentials (OIDC)
        if: matrix.target.provider == 'azure'
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Authenticate to Google Cloud (OIDC)
        if: matrix.target.provider == 'gcp'
        uses: google-github-actions/auth@v1
        with:
          token_format: "id_token"
          id_token_audience: "https://iam.googleapis.com/projects/${{ secrets.GCP_PROJECT_NUMBER }}/locations/global/workloadIdentityPools/github-pool/providers/github-provider"
          workload_identity_provider: "projects/${{ secrets.GCP_PROJECT_NUMBER }}/locations/global/workloadIdentityPools/github-pool/providers/github-provider"
          service_account: "github-actions-service-account@${{ secrets.GCP_PROJECT_ID }}.iam.gserviceaccount.com"

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Cache Python Poetry virtualenv
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/pypoetry
            ~/.virtualenvs
            prowler/.venv
          key: prowler-${{ hashFiles('prowler/poetry.lock') }}
          restore-keys: prowler-

      - name: Install Prowler and Python deps
        run: |
          git clone -b PRWLR-7257-map-ccc-objects-in-aws-provider --single-branch https://github.com/prowler-cloud/prowler
          cd prowler
          pipx install poetry
          poetry install

      - name: Deploy and scan module
        run: |
          set -euo pipefail

          echo "üöÄ Processing module: $TARGET_NAME (id: $TARGET_ID)"
          echo "üìÅ Path: $TARGET_PATH"
          echo "‚òÅÔ∏è  Provider: $TARGET_PROVIDER"
          echo "üîß Service: $TARGET_SERVICE"

          mkdir -p "$OUTPUT_DIR"

          (
              # Trap to ensure destroy always runs
              cleanup() {
                  echo "üß® Running final destroy for $TARGET_ID (even if script failed)..."
                  cd "$GITHUB_WORKSPACE/$TARGET_PATH"

                  if [ "$TARGET_PROVIDER" = "aws" ]; then
                    terraform destroy -auto-approve  -input=false || true
                  elif [ "$TARGET_PROVIDER" = "azure" ]; then
                    terraform destroy -auto-approve -input=false || true
                  elif [ "$TARGET_PROVIDER" = "gcp" ]; then
                    terraform destroy -auto-approve -input=false || true
                  fi
              }
              trap cleanup EXIT

              echo "üîß Applying module $TARGET_ID..."
              prowler_success=0

              cd "$GITHUB_WORKSPACE/$TARGET_PATH"
              if [ "$TARGET_PROVIDER" = "aws" ]; then
                terraform init
                terraform apply -auto-approve -input=false
                
                echo "üîç Running Prowler scan for $TARGET_ID..."
                cd "$GITHUB_WORKSPACE/prowler"
                set +e  # Temporarily disable exit on error for Prowler
                poetry run python prowler-cli.py aws
                prowler_success=$?
                set -e  # Re-enable exit on error
                
              elif [ "$TARGET_PROVIDER" = "azure" ]; then
                export ARM_SUBSCRIPTION_ID="${{ secrets.AZURE_SUBSCRIPTION_ID }}"
                terraform init -upgrade
                terraform apply -auto-approve -input=false
                
                echo "üîç Running Prowler scan for $TARGET_ID..."
                cd "$GITHUB_WORKSPACE/prowler"
                set +e  # Temporarily disable exit on error for Prowler
                poetry run python prowler-cli.py azure --az-cli-auth
                prowler_success=$?
                set -e  # Re-enable exit on error
                
              elif [ "$TARGET_PROVIDER" = "gcp" ]; then
                export TF_VAR_project_id="${{ secrets.GCP_PROJECT_ID }}"

                terraform init
                terraform apply -auto-approve  -var "project_id=${{ secrets.GCP_PROJECT_ID }}" -input=false
                
                echo "üîç Running Prowler scan for $TARGET_ID..."
                cd "$GITHUB_WORKSPACE/prowler"
                set +e  # Temporarily disable exit on error for Prowler
                poetry run python prowler-cli.py gcp
                prowler_success=$?
                set -e  # Re-enable exit on error
              fi
              
              if [ "$prowler_success" = 0 ]; then
                echo "‚úÖ Prowler scan completed successfully for $TARGET_ID"
              else
                echo "‚ö†Ô∏è  Prowler scan failed for $TARGET_ID (exit code: $prowler_success) but continuing workflow"
              fi

              if ls output/*.ocsf.json 1> /dev/null 2>&1; then
                latest_file=$(ls -t output/*.ocsf.json | head -n 1)
                if [ -n "$latest_file" ] && [ -f "$latest_file" ]; then
                  cp "$latest_file" "../$OUTPUT_DIR/${TARGET_ID}_ocsf.json"
                  echo "‚úÖ Successfully captured OCSF output for $TARGET_ID"
                else
                  echo "‚ö†Ô∏è  No valid OCSF file found for $TARGET_ID"
                fi
              else
                echo "‚ö†Ô∏è  No OCSF output files found for $TARGET_ID"
              fi
              
          )

      - name: Upload module results
        uses: actions/upload-artifact@v4
        with:
          name: cfi-results-${{ matrix.target.id }}
          path: |
            ${{ env.OUTPUT_DIR }}
            config/${{ matrix.target.id }}.json
